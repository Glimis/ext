<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-chart-AbstractChart'>/**
</span> * The Ext.chart package provides the capability to visualize data.
 * Each chart binds directly to a {@link Ext.data.Store store} enabling automatic updates of the chart.
 * A chart configuration object has some overall styling options as well as an array of axes
 * and series. A chart instance example could look like this:
 *
 *     new Ext.chart.CartesianChart({
 *         width: 800,
 *         height: 600,
 *         animation: true,
 *         store: store1,
 *         legend: {
 *             position: 'right'
 *         },
 *         axes: [
 *             // ...some axes options...
 *         ],
 *         series: [
 *             // ...some series options...
 *         ]
 *     });
 *
 * In this example we set the `width` and `height` of a chart; We decide whether our series are
 * animated or not and we select a store to be bound to the chart; We also set the legend to the right part of the
 * chart.
 *
 * You can register certain interactions such as {@link Ext.chart.interactions.PanZoom} on the chart by specify an
 * array of names or more specific config objects. All the events will be wired automatically.
 *
 * You can also listen to `itemXXX` events directly on charts. That case all the contained series will relay this event to the
 * chart.
 *
 * For more information about the axes and series configurations please check the documentation of
 * each series (Line, Bar, Pie, etc).
 *
 */

Ext.define('Ext.chart.AbstractChart', {

    extend: 'Ext.draw.Container',

    requires: [
        'Ext.chart.theme.Default',
        'Ext.chart.series.Series',
        'Ext.chart.interactions.Abstract',
        'Ext.chart.axis.Axis',
        'Ext.data.StoreManager',
        'Ext.chart.Legend',
        'Ext.data.Store'
    ],
    
<span id='Ext-chart-AbstractChart-property-defaultBindProperty'>    defaultBindProperty: 'store',
</span>
<span id='Ext-chart-AbstractChart-event-beforerefresh'>    /**
</span>     * @event beforerefresh
     * Fires before a refresh to the chart data is called.  If the `beforerefresh` handler returns
     * `false` the {@link #refresh} action will be canceled.
     * @param {Ext.chart.AbstractChart} this
     */

<span id='Ext-chart-AbstractChart-event-refresh'>    /**
</span>     * @event refresh
     * Fires after the chart data has been refreshed.
     * @param {Ext.chart.AbstractChart} this
     */

<span id='Ext-chart-AbstractChart-event-redraw'>    /**
</span>     * @event redraw
     * Fires after the chart is redrawn.
     * @param {Ext.chart.AbstractChart} this
     */

<span id='Ext-chart-AbstractChart-event-itemmousemove'>    /**
</span>     * @event itemmousemove
     * Fires when the mouse is moved on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemmouseup'>    /**
</span>     * @event itemmouseup
     * Fires when a mouseup event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemmousedown'>    /**
</span>     * @event itemmousedown
     * Fires when a mousedown event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemmouseover'>    /**
</span>     * @event itemmouseover
     * Fires when the mouse enters a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemmouseout'>    /**
</span>     * @event itemmouseout
     * Fires when the mouse exits a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemclick'>    /**
</span>     * @event itemclick
     * Fires when a click event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemdoubleclick'>    /**
</span>     * @event itemdoubleclick
     * Fires when a doubleclick event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtap'>    /**
</span>     * @event itemtap
     * Fires when a tap event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtapstart'>    /**
</span>     * @event itemtapstart
     * Fires when a tapstart event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtapend'>    /**
</span>     * @event itemtapend
     * Fires when a tapend event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtapcancel'>    /**
</span>     * @event itemtapcancel
     * Fires when a tapcancel event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtaphold'>    /**
</span>     * @event itemtaphold
     * Fires when a taphold event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemdoubletap'>    /**
</span>     * @event itemdoubletap
     * Fires when a doubletap event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemsingletap'>    /**
</span>     * @event itemsingletap
     * Fires when a singletap event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtouchstart'>    /**
</span>     * @event itemtouchstart
     * Fires when a touchstart event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtouchmove'>    /**
</span>     * @event itemtouchmove
     * Fires when a touchmove event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemtouchend'>    /**
</span>     * @event itemtouchend
     * Fires when a touchend event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemdragstart'>    /**
</span>     * @event itemdragstart
     * Fires when a dragstart event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemdrag'>    /**
</span>     * @event itemdrag
     * Fires when a drag event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemdragend'>    /**
</span>     * @event itemdragend
     * Fires when a dragend event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itempinchstart'>    /**
</span>     * @event itempinchstart
     * Fires when a pinchstart event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itempinch'>    /**
</span>     * @event itempinch
     * Fires when a pinch event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itempinchend'>    /**
</span>     * @event itempinchend
     * Fires when a pinchend event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */
<span id='Ext-chart-AbstractChart-event-itemswipe'>    /**
</span>     * @event itemswipe
     * Fires when a swipe event occurs on a series item.
     * @param {Ext.chart.series.Series} series
     * @param {Object} item
     * @param {Event} event
     */

<span id='Ext-chart-AbstractChart-property-version'>    /**
</span>     * @property version Current version of Sencha Charts.
     * @type {String}
     */
    version: '2.5.0',

<span id='Ext-chart-AbstractChart-property-delegationRegex'>    delegationRegex: /^item([a-z]+)$/i,
</span>
<span id='Ext-chart-AbstractChart-property-domEvents'>    domEvents: new RegExp(&quot;click|focus|blur|paste|input|mousemove|mousedown|mouseup|mouseover|mouseout|keyup|keydown|keypress|submit|&quot;+
</span>                          &quot;pinch|pinchstart|pinchend|touchmove|touchstart|touchend|rotate|rotatestart|rotateend|drag|dragstart|dragend|tap|doubletap|singletap&quot;),

    config: {

<span id='Ext-chart-AbstractChart-cfg-store'>        /**
</span>         * @cfg {Ext.data.Store} store
         * The store that supplies data to this chart.
         */
        store: 'ext-empty-store',

<span id='Ext-chart-AbstractChart-cfg-theme'>        /**
</span>         * @cfg {String} [theme=&quot;default&quot;]
         * The name of the theme to be used. A theme defines the colors and styles
         * used by the series, axes, markers and other chart components.
         * Please see the documentation for the {@link Ext.chart.theme.Base} class for more information.
         * Possible theme values are:
         *   - 'green', 'sky', 'red', 'purple', 'blue', 'yellow'
         *   - 'category1' to 'category6'
         *   - and the above theme names with the '-gradients' suffix, e.g. 'green-gradients'
         */
        theme: 'default',

<span id='Ext-chart-AbstractChart-cfg-style'>        /**
</span>         * @cfg {Object} style
         * The style for the chart component.
         */
        style: null,

<span id='Ext-chart-AbstractChart-cfg-shadow'>        /**
</span>         * @cfg {Boolean/Object} shadow (optional) `true` for the default shadow configuration 
         * `{shadowOffsetX: 2, shadowOffsetY: 2, shadowBlur: 3, shadowColor: '#444'}`
         * or a standard shadow config object to be used for default chart shadows.
         */
        shadow: false,

<span id='Ext-chart-AbstractChart-cfg-animation'>        /**
</span>         * @cfg {Boolean/Object} animation (optional) `true` for the default animation (easing: 'ease' and duration: 500)
         * or a standard animation config object to be used for default chart animations.
         */
        animation: !Ext.isIE8,

<span id='Ext-chart-AbstractChart-cfg-series'>        /**
</span>         * @cfg {Ext.chart.series.Series/Array} series
         * Array of {@link Ext.chart.series.Series Series} instances or config objects. For example:
         *
         *     series: [{
         *         type: 'column',
         *         axis: 'left',
         *         listeners: {
         *             'afterrender': function() {
         *                 console.log('afterrender');
         *             }
         *         },
         *         xField: 'category',
         *         yField: 'data1'
         *     }]
         */
        series: [],

<span id='Ext-chart-AbstractChart-cfg-axes'>        /**
</span>         * @cfg {Ext.chart.axis.Axis/Array/Object} axes
         * Array of {@link Ext.chart.axis.Axis Axis} instances or config objects. For example:
         *
         *     axes: [{
         *         type: 'numeric',
         *         position: 'left',
         *         title: 'Number of Hits',
         *         minimum: 0
         *     }, {
         *         type: 'category',
         *         position: 'bottom',
         *         title: 'Month of the Year'
         *     }]
         */
        axes: [],

<span id='Ext-chart-AbstractChart-cfg-legend'>        /**
</span>         * @cfg {Ext.chart.Legend/Object} legend
         */
        legend: null,

<span id='Ext-chart-AbstractChart-cfg-colors'>        /**
</span>         * @cfg {Array} colors Array of colors/gradients to override the color of items and legends.
         */
        colors: null,

<span id='Ext-chart-AbstractChart-cfg-insetPadding'>        /**
</span>         * @cfg {Object|Number|String} insetPadding The amount of inset padding in pixels for the chart.
         * Inset padding is the padding from the boundary of the chart to any of its contents.
         */
        insetPadding: {
            top: 10,
            left: 10,
            right: 10,
            bottom: 10
        },

<span id='Ext-chart-AbstractChart-cfg-background'>        /**
</span>         * @cfg {Object} background Set the chart background. This can be a gradient object, image, or color.
         *
         * For example, if `background` were to be a color we could set the object as
         *
         *     background: '#ccc'
         *
         * You can specify an image by using:
         *
         *     background: {
         *         type: 'image',
         *         src: 'http://path.to.image/'
         *     }
         *
         * Also you can specify a gradient by using the gradient object syntax:
         *
         *     background: {
         *         type: 'linear',
         *         degrees: 0,
         *         stops: [
         *             {
         *                 offset: 0,
         *                 color: 'white'
         *             },
         *             {
         *                 offset: 1,
         *                 color: 'blue'
         *             }
         *         ]
         *     }
         */
        background: null,

<span id='Ext-chart-AbstractChart-cfg-interactions'>        /**
</span>         * @cfg {Array} interactions
         * Interactions are optional modules that can be plugged in to a chart to allow the user to interact
         * with the chart and its data in special ways. The `interactions` config takes an Array of Object
         * configurations, each one corresponding to a particular interaction class identified by a `type` property:
         *
         *     new Ext.chart.AbstractChart({
         *         renderTo: Ext.getBody(),
         *         width: 800,
         *         height: 600,
         *         store: store1,
         *         axes: [
         *             // ...some axes options...
         *         ],
         *         series: [
         *             // ...some series options...
         *         ],
         *         interactions: [{
         *             type: 'interactiontype'
         *             // ...additional configs for the interaction...
         *         }]
         *     });
         *
         * When adding an interaction which uses only its default configuration (no extra properties other than `type`),
         * you can alternately specify only the type as a String rather than the full Object:
         *
         *     interactions: ['reset', 'rotate']
         *
         * The current supported interaction types include:
         *
         * - {@link Ext.chart.interactions.PanZoom panzoom} - allows pan and zoom of axes
         * - {@link Ext.chart.interactions.ItemHighlight itemhighlight} - allows highlighting of series data points
         * - {@link Ext.chart.interactions.ItemInfo iteminfo} - allows displaying details of a data point in a popup panel
         * - {@link Ext.chart.interactions.Rotate rotate} - allows rotation of pie and radar series
         *
         * See the documentation for each of those interaction classes to see how they can be configured.
         *
         * Additional custom interactions can be registered using `'interactions.'` alias prefix.
         */
        interactions: [],

<span id='Ext-chart-AbstractChart-cfg-mainRect'>        /**
</span>         * @private
         * The main area of the chart where grid and series are drawn.
         */
        mainRect: null,

<span id='Ext-chart-AbstractChart-cfg-resizeHandler'>        /**
</span>         * @private
         * Override value.
         */
        resizeHandler: null,

<span id='Ext-chart-AbstractChart-cfg-highlightItem'>        /**
</span>         * @readonly
         * @cfg {Object} highlightItem
         * The current highlight item in the chart.
         * The object must be the one that you get from item events.
         *
         * Note that series can also own highlight items.
         * This notion is separate from this one and should not be used at the same time.
         */
        highlightItem: null
    },

<span id='Ext-chart-AbstractChart-property-resizing'>    /**
</span>     * @private
     */
    resizing: 0,

<span id='Ext-chart-AbstractChart-property-animationSuspended'>    /**
</span>     * Toggle for chart interactions that require animation to be suspended.
     * @private
     */
    animationSuspended: 0,

<span id='Ext-chart-AbstractChart-property-surfaceZIndexes'>    /**
</span>     * @private The z-indexes to use for the various surfaces
     */
    surfaceZIndexes: {
        background: 0,
        main: 1,
        grid: 2,
        series: 3,
        axis: 4,
        chart: 5,
        overlay: 6,
        events: 7
    },

<span id='Ext-chart-AbstractChart-property-animating'>    animating: 0,
</span>
<span id='Ext-chart-AbstractChart-property-layoutSuspended'>    layoutSuspended: 0,
</span>
<span id='Ext-chart-AbstractChart-method-applyAnimation'>    applyAnimation: function (newAnimation, oldAnimation) {
</span>        if (!newAnimation) {
            newAnimation = {
                duration: 0
            };
        } else if (newAnimation === true) {
            newAnimation = {
                easing: 'easeInOut',
                duration: 500
            };
        }
        return oldAnimation ? Ext.apply({}, newAnimation, oldAnimation) : newAnimation;
    },

<span id='Ext-chart-AbstractChart-method-applyInsetPadding'>    applyInsetPadding: function (padding, oldPadding) {
</span>        if (!Ext.isObject(padding)) {
            return Ext.util.Format.parseBox(padding);
        } else if (!oldPadding) {
            return padding;
        } else {
            return Ext.apply(oldPadding, padding);
        }
    },

<span id='Ext-chart-AbstractChart-method-suspendAnimation'>    suspendAnimation: function () {
</span>        this.animationSuspended++;
        if (this.animationSuspended === 1) {
            var series = this.getSeries(), i = -1, n = series.length;
            while (++i &lt; n) {
                //update animation config to not animate
                series[i].setAnimation(this.getAnimation());
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-resumeAnimation'>    resumeAnimation: function () {
</span>        this.animationSuspended--;
        if (this.animationSuspended === 0) {
            var series = this.getSeries(), i = -1, n = series.length;
            while (++i &lt; n) {
                //update animation config to animate
                series[i].setAnimation(this.getAnimation());
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-suspendChartLayout'>    suspendChartLayout: function () {
</span>        this.layoutSuspended++;
        if (this.layoutSuspended === 1) {
            if (this.scheduledLayoutId) {
                this.layoutInSuspension = true;
                this.cancelLayout();
            } else {
                this.layoutInSuspension = false;
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-resumeChartLayout'>    resumeChartLayout: function () {
</span>        this.layoutSuspended--;
        if (this.layoutSuspended === 0) {
            if (this.layoutInSuspension) {
                this.scheduleLayout();
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-cancelLayout'>    /**
</span>     * Cancel a scheduled layout.
     */
    cancelLayout: function () {
        if (this.scheduledLayoutId) {
            Ext.draw.Animator.cancel(this.scheduledLayoutId);
            this.scheduledLayoutId = null;
        }
    },

<span id='Ext-chart-AbstractChart-method-scheduleLayout'>    /**
</span>     * Schedule a layout at next frame.
     */
    scheduleLayout: function () {
        var me = this;

        if (me.rendered &amp;&amp; !me.scheduledLayoutId) {
            me.scheduledLayoutId = Ext.draw.Animator.schedule('doScheduleLayout', me);
        }
    },

<span id='Ext-chart-AbstractChart-method-doScheduleLayout'>    doScheduleLayout: function () {
</span>        if (this.layoutSuspended) {
            this.layoutInSuspension = true;
        } else {
            this.performLayout();
        }
    },

<span id='Ext-chart-AbstractChart-method-getAnimation'>    getAnimation: function () {
</span>        if (this.resizing || this.animationSuspended) {
            return {
                duration: 0
            };
        } else {
            return this.callParent();
        }
    },

<span id='Ext-chart-AbstractChart-method-constructor'>    constructor: function (config) {
</span>        var me = this;

        me.itemListeners = {};
        me.surfaceMap = {};

        me.isInitializing = true;
        me.suspendChartLayout();
        me.callParent(arguments);
        delete me.isInitializing;

        me.getSurface('main');
        me.getSurface('chart').setFlipRtlText(me.getInherited().rtl);
        me.getSurface('overlay').waitFor(me.getSurface('series'));
        me.resumeChartLayout();
    },

<span id='Ext-chart-AbstractChart-method-applySprites'>    applySprites: function (sprites) {
</span>        var surface = this.getSurface('chart');

        sprites = Ext.Array.from(sprites);
        surface.removeAll(true);
        surface.add(sprites);
    },

<span id='Ext-chart-AbstractChart-method-initItems'>    initItems: function () {
</span>        var items = this.items,
            i, ln, item;
        if (items &amp;&amp; !items.isMixedCollection) {
            this.items = [];
            items = Ext.Array.from(items);
            for (i = 0, ln = items.length; i &lt; ln; i++) {
                item = items[i];
                if (item.type) {
                    Ext.Error.raise(&quot;To add custom sprites to the chart use the 'sprites' config.&quot;);
                } else {
                    this.items.push(item);
                }
            }
        }
        this.callParent();
    },

<span id='Ext-chart-AbstractChart-method-applyBackground'>    applyBackground: function (newBackground, oldBackground) {
</span>        var surface = this.getSurface('background');
        if (newBackground) {
            surface.remove(oldBackground, true);
            if (newBackground.type === 'image' &amp;&amp; Ext.isString(newBackground.src)) {
                oldBackground = surface.add(newBackground);
            } else {
                oldBackground = surface.add({
                    type: 'rect',
                    fillStyle: newBackground
                });
            }
        }
        return oldBackground;
    },

<span id='Ext-chart-AbstractChart-method-getLegendStore'>    /**
</span>     * Return the legend store that contains all the legend information.
     * This information is collected from all the series.
     * @return {Ext.data.Store}
     */
    getLegendStore: function () {
        return this.legendStore;
    },

<span id='Ext-chart-AbstractChart-method-refreshLegendStore'>    refreshLegendStore: function () {
</span>        if (this.getLegendStore()) {
            var i, ln,
                series = this.getSeries(), seriesItem,
                legendData = [];
            if (series) {
                for (i = 0, ln = series.length; i &lt; ln; i++) {
                    seriesItem = series[i];
                    if (seriesItem.getShowInLegend()) {
                        seriesItem.provideLegendInfo(legendData);
                    }
                }
            }
            this.getLegendStore().setData(legendData);
        }
    },

<span id='Ext-chart-AbstractChart-method-resetLegendStore'>    resetLegendStore: function () {
</span>        if (this.getLegendStore()) {
            var data = this.getLegendStore().getData().items,
                i, ln = data.length,
                record;
            for (i = 0; i &lt; ln; i++) {
                record = data[i];
                record.beginEdit();
                record.set('disabled', false);
                record.commit();
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-onUpdateLegendStore'>    onUpdateLegendStore: function (store, record) {
</span>        var series = this.getSeries(), seriesItem;
        if (record &amp;&amp; series) {
            seriesItem = series.map[record.get('series')];
            if (seriesItem) {
                seriesItem.setHiddenByIndex(record.get('index'), record.get('disabled'));
                this.redraw();
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-resizeHandler'>    resizeHandler: function (size) {
</span>        var me = this;
        me.scheduleLayout();
        return false;
    },

<span id='Ext-chart-AbstractChart-method-applyMainRect'>    applyMainRect: function (newRect, rect) {
</span>        if (!rect) {
            return newRect;
        }
        this.getSeries();
        this.getAxes();
        if (newRect[0] === rect[0] &amp;&amp;
            newRect[1] === rect[1] &amp;&amp;
            newRect[2] === rect[2] &amp;&amp;
            newRect[3] === rect[3]) {
            return rect;
        } else {
            return newRect;
        }
    },

<span id='Ext-chart-AbstractChart-method-getAxis'>    getAxis: function (axis) {
</span>        if (axis instanceof Ext.chart.axis.Axis) {
            return axis;
        } else if (Ext.isNumber(axis)) {
            return this.getAxes()[axis];
        } else if (Ext.isString(axis)) {
            return Ext.ComponentMgr.get(axis);
        } else {
            return null;
        }
    },

<span id='Ext-chart-AbstractChart-method-getSurface'>    getSurface: function (name, type) {
</span>        name = name || 'main';
        type = type || name;
        var me = this,
            surface = this.callParent([name]),
            zIndexes = me.surfaceZIndexes;
        if (type in zIndexes) {
            surface.element.setStyle('zIndex', zIndexes[type]);
        }
        if (!me.surfaceMap[type]) {
            me.surfaceMap[type] = [];
        }
        if (Ext.Array.indexOf(me.surfaceMap[type], (surface)) &lt; 0) {
            surface.type = type;
            me.surfaceMap[type].push(surface);
        }
        return surface;
    },

<span id='Ext-chart-AbstractChart-method-applyAxes'>    applyAxes: function (newAxes, oldAxes) {
</span>        this.resizing++;

        this.getStore();
        if (!oldAxes) {
            oldAxes = [];
            oldAxes.map = {};
        }
        var result = [], i, ln, axis, oldAxis, linkedTo, id,
            positions = {left: 'right', right: 'left'},
            oldMap = oldAxes.map;
        result.map = {};
        newAxes = Ext.Array.from(newAxes, true);
        for (i = 0, ln = newAxes.length; i &lt; ln; i++) {
            axis = Ext.Object.chain(newAxes[i]);
            if (!axis) {
                continue;
            }

            linkedTo = axis.linkedTo;
            id = axis.id;
            if (Ext.isNumber(linkedTo)) {
                axis = Ext.merge({}, newAxes[linkedTo], axis);
            } else if (Ext.isString(linkedTo)) {
                Ext.Array.each(newAxes, function (item) {
                    if (item.id === axis.linkedTo) {
                        axis = Ext.merge({}, item, axis);
                        return false;
                    }
                });
            }
            axis.id = id;

            if (this.getInherited().rtl) {
                axis.position = positions[axis.position] || axis.position;
            }
            axis = Ext.factory(axis, null, oldAxis = oldMap[axis.getId &amp;&amp; axis.getId() || axis.id], 'axis');
            if (axis) {
                axis.setChart(this);
                result.push(axis);
                result.map[axis.getId()] = axis;
                if (!oldAxis) {
                    axis.on('animationstart', 'onAnimationStart', this);
                    axis.on('animationend', 'onAnimationEnd', this);
                }
            }
        }

        for (i in oldMap) {
            if (!result.map[i]) {
                oldMap[i].destroy();
            }
        }

        this.resizing--;

        return result;
    },

<span id='Ext-chart-AbstractChart-method-updateAxes'>    updateAxes: function (newAxes) {
</span>        this.scheduleLayout();
    },

<span id='Ext-chart-AbstractChart-method-circularCopyArray'>    circularCopyArray: function(inArray, startIndex, count) {
</span>        var outArray = [],
            i, len = inArray &amp;&amp; inArray.length;
        if (len) {
            for (i = 0; i &lt; count; i++) {
                outArray.push(inArray[(startIndex + i) % len]);
            }
        }
        return outArray;
    },

<span id='Ext-chart-AbstractChart-method-circularCopyObject'>    circularCopyObject: function(inObject, startIndex, count) {
</span>        var me = this,
            name, value, outObject = {};
        if (count) {
            for (name in inObject) {
                if (inObject.hasOwnProperty(name)) {
                    value = inObject[name];
                    if (Ext.isArray(value)) {
                        outObject[name] = me.circularCopyArray(value, startIndex, count);
                    } else {
                        outObject[name] = value;
                    }
                }
            }
        }
        return outObject;
    },

<span id='Ext-chart-AbstractChart-method-getColors'>    getColors: function () {
</span>        var me = this,
            configColors = me.config.colors,
            theme = me.getTheme();
        if (Ext.isArray(configColors) &amp;&amp; configColors.length &gt; 0) {
            configColors = me.applyColors(configColors);
        }
        return configColors || (theme &amp;&amp; theme.getColors());
    },

<span id='Ext-chart-AbstractChart-method-applyColors'>    applyColors: function (newColors) {
</span>        newColors = Ext.Array.map(newColors, function(color) {
            if (Ext.isString(color)) {
                return color;
            } else {
                return color.toString();
            }
        });
        return newColors;
    },

<span id='Ext-chart-AbstractChart-method-updateColors'>    updateColors: function (newColors) {
</span>        var me = this,
            theme = me.getTheme(),
            colors = newColors || (theme &amp;&amp; theme.getColors()),
            colorCount = colors.length,
            colorIndex = 0,
            series = me.getSeries(),
            seriesCount = series &amp;&amp; series.length,
            i, seriesItem, seriesColors, seriesColorCount;

        if (colorCount) {
            for (i = 0; i &lt; seriesCount; i++) {
                seriesItem = series[i];
                seriesColorCount = seriesItem.themeColorCount();
                seriesColors = me.circularCopyArray(colors, colorIndex, seriesColorCount);
                colorIndex += seriesColorCount;
                seriesItem.updateChartColors(seriesColors);
            }
        }
        me.refreshLegendStore();
    },

<span id='Ext-chart-AbstractChart-method-applyTheme'>    applyTheme: function (theme) {
</span>        if (theme &amp;&amp; theme.isTheme) {
            return theme;
        }
        return Ext.Factory.chartTheme(theme);
    },

<span id='Ext-chart-AbstractChart-method-updateTheme'>    updateTheme: function (theme) {
</span>        var me = this,
            axes = me.getAxes(),
            series = me.getSeries(),
            colors = me.getColors(),
            seriesItem, seriesTheme,
            colorIndex = 0,
            markerIndex = 0,
            markerCount,
            colorCount,
            i;

        me.updateChartTheme(theme);

        for (i = 0; i &lt; axes.length; i++) {
            axes[i].updateTheme(theme);
        }

        for (i = 0; i &lt; series.length; i++) {
            series[i].updateTheme(theme);

            seriesItem = series[i];
            seriesTheme = {};

            if (theme.getSeriesThemes) {
                colorCount = seriesItem.themeColorCount();
                seriesTheme.subStyle = me.circularCopyObject(theme.getSeriesThemes(), colorIndex, colorCount);
                colorIndex += colorCount;
            } else {
                seriesTheme.subStyle = {};
            }

            if (theme.getMarkerThemes) {
                markerCount = seriesItem.themeMarkerCount();
                seriesTheme.markerSubStyle = me.circularCopyObject(theme.getMarkerThemes(), markerIndex, markerCount);
                markerIndex += markerCount;
            } else {
                seriesTheme.markerSubStyle = {};
            }
        }

        me.updateSpriteTheme(theme);

        me.updateColors(colors);
    },

<span id='Ext-chart-AbstractChart-method-updateChartTheme'>    updateChartTheme: function (theme) {
</span>        var me = this,
            chartTheme = theme.getChart(),
            initialConfig = me.getInitialConfig(),
            defaultConfig = me.defaultConfig,
            configs = me.getConfigurator().configs,
            genericChartTheme = chartTheme.defaults,
            specificChartTheme = chartTheme[me.xtype],
            key, value, isObjValue, initialValue, cfg;

        chartTheme = Ext.merge({}, genericChartTheme, specificChartTheme);
        for (key in chartTheme) {
            value = chartTheme[key];
            cfg = configs[key];
            if (value !== null &amp;&amp; value !== undefined &amp;&amp; cfg) {
                initialValue = initialConfig[key];
                isObjValue = Ext.isObject(value);
                if (initialValue === defaultConfig[key] || isObjValue) {
                    if (isObjValue) {
                        value = Ext.merge({}, value, initialValue);
                    }
                    me[cfg.names.set](value);
                }
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-updateSpriteTheme'>    updateSpriteTheme: function (theme) {
</span>        var me = this,
            chartSurface = me.getSurface('chart'),
            sprites = chartSurface.getItems(),
            styles = theme.getSprites(),
            sprite, style,
            key, attr,
            isText,
            i, ln;

        for (i = 0, ln = sprites.length; i &lt; ln; i++) {
            sprite = sprites[i];
            style = styles[sprite.type];
            if (style) {
                attr = {};
                isText = sprite.type === 'text';
                for (key in style) {
                    if (!(key in sprite.config)) {
                        // Setting individual font attributes will take over the 'font' shorthand
                        // attribute, but this behavior is undesireable for theming.
                        if (!(isText &amp;&amp; key.indexOf('font') === 0 &amp;&amp; sprite.config.font)) {
                            attr[key] = style[key];
                        }
                    }
                }
                sprite.setAttributes(attr);
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-applySeries'>    applySeries: function (newSeries, oldSeries) {
</span>        var me = this,
            result = [],
            oldMap, oldSeriesItem,
            i, ln, series;

        me.resizing++;

        me.getAxes();
        if (!oldSeries) {
            oldSeries = [];
            oldMap = oldSeries.map = {};
        }
        result.map = {};
        newSeries = Ext.Array.from(newSeries, true);
        for (i = 0, ln = newSeries.length; i &lt; ln; i++) {
            series = newSeries[i];
            if (!series) {
                continue;
            }
            oldSeriesItem = oldSeries.map[series.getId &amp;&amp; series.getId() || series.id];
            if (series instanceof Ext.chart.series.Series) {
                if (oldSeriesItem !== series) {
                    // Replacing
                    if (oldSeriesItem) {
                        oldSeriesItem.destroy();
                    }
                    me.addItemListenersToSeries(series);
                }
                series.setChart(me);
            } else if (Ext.isObject(series)) {
                if (oldSeriesItem) {
                    // Update
                    oldSeriesItem.setConfig(series);
                    series = oldSeriesItem;
                } else {
                    // Create a series.
                    if (Ext.isString(series)) {
                        series = Ext.create(series.xclass || ('series.' + series), {chart: me});
                    } else {
                        series.chart = me;
                        series = Ext.create(series.xclass || ('series.' + series.type), series);
                    }
                    series.on('animationstart', 'onAnimationStart', me);
                    series.on('animationend', 'onAnimationEnd', me);
                    me.addItemListenersToSeries(series);
                }
            }

            result.push(series);
            result.map[series.getId()] = series;
        }

        for (i in oldMap) {
            if (!result.map[oldMap[i].getId()]) {
                oldMap[i].destroy();
            }
        }

        me.resizing--;

        return result;
    },

<span id='Ext-chart-AbstractChart-method-applyLegend'>    applyLegend: function (newLegend, oldLegend) {
</span>        return Ext.factory(newLegend, Ext.chart.Legend, oldLegend);
    },

<span id='Ext-chart-AbstractChart-method-updateLegend'>    updateLegend: function (legend, oldLegend) {
</span>        if (oldLegend) {
            oldLegend.destroy();
        }
        if (legend) {
            this.getItems();
            this.legendStore = new Ext.data.Store({
                autoDestroy: true,
                fields: [
                    'id', 'name', 'mark', 'disabled', 'series', 'index'
                ]
            });
            legend.setStore(this.legendStore);
            this.refreshLegendStore();
            this.legendStore.on('update', 'onUpdateLegendStore', this);
        }
    },

<span id='Ext-chart-AbstractChart-method-setParent'>    setParent: function (parent) {
</span>        this.callParent(arguments);
        if (parent &amp;&amp; this.getLegend()) {
            parent.add(this.getLegend());
        }
    },

<span id='Ext-chart-AbstractChart-method-updateSeries'>    updateSeries: function (newSeries, oldSeries) {
</span>        this.resizing++;

        this.fireEvent('serieschange', this, newSeries, oldSeries);
        this.refreshLegendStore();
        this.scheduleLayout();

        this.resizing--;
    },

<span id='Ext-chart-AbstractChart-method-applyInteractions'>    applyInteractions: function (interactions, oldInteractions) {
</span>        if (!oldInteractions) {
            oldInteractions = [];
            oldInteractions.map = {};
        }
        var me = this,
            result = [], oldMap = oldInteractions.map,
            i, ln, interaction;
        result.map = {};
        interactions = Ext.Array.from(interactions, true);
        for (i = 0, ln = interactions.length; i &lt; ln; i++) {
            interaction = interactions[i];
            if (!interaction) {
                continue;
            }
            interaction = Ext.factory(interaction, null, oldMap[interaction.getId &amp;&amp; interaction.getId() || interaction.id], 'interaction');
            if (interaction) {
                interaction.setChart(me);
                result.push(interaction);
                result.map[interaction.getId()] = interaction;
            }
        }

        for (i in oldMap) {
            if (!result.map[oldMap[i]]) {
                oldMap[i].destroy();
            }
        }
        return result;
    },

<span id='Ext-chart-AbstractChart-method-applyStore'>    applyStore: function (store) {
</span>        return store &amp;&amp; Ext.StoreManager.lookup(store);
    },

<span id='Ext-chart-AbstractChart-method-updateStore'>    updateStore: function (newStore, oldStore) {
</span>        var me = this;
        if (oldStore) {
            oldStore.unAfter({
                datachanged: 'onDataChanged',
                update: 'onDataChanged',
                scope: me
            });
            if (oldStore.autoDestroy) {
                oldStore.destroy();
            }
        }
        if (newStore) {
            newStore.onAfter({
                datachanged: 'onDataChanged',
                update: 'onDataChanged',
                scope: me
            });
        }

        me.fireEvent('storechange', newStore, oldStore);
        me.onDataChanged();
    },

<span id='Ext-chart-AbstractChart-method-redraw'>    /**
</span>     * Redraw the chart. If animations are set this will animate the chart too.
     */
    redraw: function () {
        this.fireEvent('redraw', this);
    },

<span id='Ext-chart-AbstractChart-method-performLayout'>    performLayout: function () {
</span>        var me = this,
            size = me.innerElement.getSize(),
            chartRect = [0, 0, size.width, size.height],
            background = me.getBackground();

        me.hasFirstLayout = true;
        me.fireEvent('layout');
        me.cancelLayout();
        me.getSurface('background').setRect(chartRect);
        me.getSurface('chart').setRect(chartRect);
        background.setAttributes({
            width: size.width,
            height: size.height
        });
    },

<span id='Ext-chart-AbstractChart-method-getEventXY'>    // Converts page coordinates into chart's 'main' surface coordinates.
</span>    getEventXY: function (e) {
        return this.getSurface().getEventXY(e);
    },

<span id='Ext-chart-AbstractChart-method-getItemForPoint'>    /**
</span>     * Given an x/y point relative to the chart, find and return the first series item that
     * matches that point.
     * @param {Number} x
     * @param {Number} y
     * @return {Object} An object with `series` and `item` properties, or `false` if no item found.
     */
    getItemForPoint: function (x, y) {
        var me = this,
            items = me.getSeries(),
            l = items.length,
            // If we haven't drawn yet, don't attempt to find any items.
            i = me.hasFirstLayout ? l - 1 : -1,
            series, item;

        // Iterate from the end so that the series that are drawn later get hit tested first.
        while (i &gt;= 0) {
            series = items[i];
            item = series.getItemForPoint(x, y);
            if (item) {
                return item;
            }
            i--;
        }

        return null;
    },

<span id='Ext-chart-AbstractChart-method-getItemsForPoint'>    /**
</span>     * Given an x/y point relative to the chart, find and return all series items that match that point.
     * @param {Number} x
     * @param {Number} y
     * @return {Array} An array of objects with `series` and `item` properties.
     */
    getItemsForPoint: function (x, y) {
        var me = this,
            series = me.getSeries(),
            seriesItem,
            items = [];

        for (var i = 0; i &lt; series.length; i++) {
            seriesItem = series[i];
            var item = seriesItem.getItemForPoint(x, y);
            if (item) {
                items.push(item);
            }
        }

        return items;
    },

<span id='Ext-chart-AbstractChart-property-delayThicknessChanged'>    /**
</span>     * @private
     */
    delayThicknessChanged: 0,

<span id='Ext-chart-AbstractChart-property-thicknessChanged'>    /**
</span>     * @private
     */
    thicknessChanged: false,

<span id='Ext-chart-AbstractChart-method-suspendThicknessChanged'>    /**
</span>     * Suspend the layout initialized by thickness change
     */
    suspendThicknessChanged: function () {
        this.delayThicknessChanged++;
    },

<span id='Ext-chart-AbstractChart-method-resumeThicknessChanged'>    /**
</span>     * Resume the layout initialized by thickness change
     */
    resumeThicknessChanged: function () {
        if (this.delayThicknessChanged &gt; 0) {
            this.delayThicknessChanged--;
            if (this.delayThicknessChanged === 0 &amp;&amp; this.thicknessChanged) {
                this.onThicknessChanged();
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-onAnimationStart'>    onAnimationStart: function () {
</span>        this.fireEvent('animationstart', this);
    },

<span id='Ext-chart-AbstractChart-method-onAnimationEnd'>    onAnimationEnd: function () {
</span>        this.fireEvent('animationend', this);
    },

<span id='Ext-chart-AbstractChart-method-onThicknessChanged'>    onThicknessChanged: function () {
</span>        if (this.delayThicknessChanged === 0) {
            this.thicknessChanged = false;
            this.performLayout();
        } else {
            this.thicknessChanged = true;
        }
    },

<span id='Ext-chart-AbstractChart-method-onDataChanged'>    /**
</span>     * @private
     */
    onDataChanged: function () {
        var me = this;
        if (me.isInitializing) {
            return;
        }
        var rect = me.getMainRect(),
            store = me.getStore(),
            series = me.getSeries(),
            axes = me.getAxes(),
            colors = me.getColors(),
            i, ln;

        if (!store || !axes || !series) {
            return;
        }
        if (!rect) { // The chart hasn't been rendered yet.
            me.on({
                redraw: me.onDataChanged,
                scope: me,
                single: true
            });
            return;
        }
        for (i = 0, ln = series.length; i &lt; ln; i++) {
            series[i].processData();
        }
        me.updateColors(colors);
        me.redraw();
    },

<span id='Ext-chart-AbstractChart-method-bindStore'>    /**
</span>     * Changes the data store bound to this chart and refreshes it.
     * @param {Ext.data.Store} store The store to bind to this chart.
     */
    bindStore: function (store) {
        this.setStore(store);
    },

<span id='Ext-chart-AbstractChart-method-applyHighlightItem'>    applyHighlightItem: function (newHighlightItem, oldHighlightItem) {
</span>        if (newHighlightItem === oldHighlightItem) {
            return;
        }
        if (Ext.isObject(newHighlightItem) &amp;&amp; Ext.isObject(oldHighlightItem)) {
            if (newHighlightItem.sprite === oldHighlightItem.sprite &amp;&amp;
                newHighlightItem.index === oldHighlightItem.index
                ) {
                return;
            }
        }
        return newHighlightItem;
    },

<span id='Ext-chart-AbstractChart-method-updateHighlightItem'>    updateHighlightItem: function (newHighlightItem, oldHighlightItem) {
</span>        if (oldHighlightItem) {
            oldHighlightItem.series.setAttributesForItem(oldHighlightItem, {highlighted: false});
        }
        if (newHighlightItem) {
            newHighlightItem.series.setAttributesForItem(newHighlightItem, {highlighted: true});
            this.fireEvent('itemhighlight', newHighlightItem);
        }
    },

<span id='Ext-chart-AbstractChart-method-addItemListenersToSeries'>    addItemListenersToSeries: function (series) {
</span>        for (var name in this.itemListeners) {
            var listenerMap = this.itemListeners[name], i, ln;
            for (i = 0, ln = listenerMap.length; i &lt; ln; i++) {
                series.addListener.apply(series, listenerMap[i]);
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-addItemListener'>    addItemListener: function (name, fn, scope, options, order) {
</span>        var listenerMap = this.itemListeners[name] || (this.itemListeners[name] = []),
            series = this.getSeries(), seriesItem,
            i, ln;
        listenerMap.push([name, fn, scope, options, order]);
        if (series) {
            for (i = 0, ln = series.length; i &lt; ln; i++) {
                seriesItem = series[i];
                seriesItem.addListener(name, fn, scope, options, order);
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-remoteItemListener'>    remoteItemListener: function (name, fn, scope, options, order) {
</span>        var listenerMap = this.itemListeners[name],
            series = this.getSeries(), seriesItem,
            i, ln;
        if (listenerMap) {
            for (i = 0, ln = listenerMap.length; i &lt; ln; i++) {
                if (listenerMap[i].fn === fn) {
                    listenerMap.splice(i, 1);
                    if (series) {
                        for (i = 0, ln = series.length; i &lt; ln; i++) {
                            seriesItem = series[i];
                            seriesItem.removeListener(name, fn, scope, options, order);
                        }
                    }
                    break;
                }
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-doAddListener'>    doAddListener: function (name, fn, scope, options, order) {
</span>        if (name.match(this.delegationRegex)) {
            return this.addItemListener(name, fn, scope || this, options, order);
        } else if (name.match(this.domEvents)) {
            return this.element.doAddListener.apply(this.element, arguments);
        } else {
            return this.callParent(arguments);
        }
    },

<span id='Ext-chart-AbstractChart-method-doRemoveListener'>    doRemoveListener: function (name, fn, scope, options, order) {
</span>        if (name.match(this.delegationRegex)) {
            return this.remoteItemListener(name, fn, scope || this, options, order);
        } else if (name.match(this.domEvents)) {
            return this.element.doRemoveListener.apply(this.element, arguments);
        } else {
            return this.callParent(arguments);
        }
    },

<span id='Ext-chart-AbstractChart-method-onItemRemove'>    onItemRemove: function (item) {
</span>        this.callParent(arguments);
        if (this.surfaceMap) {
            Ext.Array.remove(this.surfaceMap[item.type], item);
            if (this.surfaceMap[item.type].length === 0) {
                delete this.surfaceMap[item.type];
            }
        }
    },

<span id='Ext-chart-AbstractChart-method-destroy'>    // @private remove gently.
</span>    destroy: function () {
        var me = this,
            emptyArray = [],
            legend = me.getLegend();
        me.surfaceMap = null;
        me.setHighlightItem(null);
        me.setSeries(emptyArray);
        me.setAxes(emptyArray);
        me.setInteractions(emptyArray);
        if (legend) {
            legend.destroy();
            me.setLegend(null);
        }
        me.legendStore = null;
        me.setStore(null);
        me.cancelLayout();
        this.callParent(arguments);
    },

    /* ---------------------------------
     Methods needed for ComponentQuery
     ----------------------------------*/

<span id='Ext-chart-AbstractChart-method-getRefItems'>    /**
</span>     * @private
     * @param {Boolean} deep
     * @return {Array}
     */
    getRefItems: function (deep) {
        var me = this,
            series = me.getSeries(),
            axes = me.getAxes(),
            interaction = me.getInteractions(),
            ans = [], i, ln;

        for (i = 0, ln = series.length; i &lt; ln; i++) {
            ans.push(series[i]);
            if (series[i].getRefItems) {
                ans.push.apply(ans, series[i].getRefItems(deep));
            }
        }

        for (i = 0, ln = axes.length; i &lt; ln; i++) {
            ans.push(axes[i]);
            if (axes[i].getRefItems) {
                ans.push.apply(ans, axes[i].getRefItems(deep));
            }
        }

        for (i = 0, ln = interaction.length; i &lt; ln; i++) {
            ans.push(interaction[i]);
            if (interaction[i].getRefItems) {
                ans.push.apply(ans, interaction[i].getRefItems(deep));
            }
        }

        return ans;
    }

});
</pre>
</body>
</html>
